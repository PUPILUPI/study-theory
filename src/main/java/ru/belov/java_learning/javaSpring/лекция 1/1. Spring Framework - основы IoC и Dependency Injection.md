![](library_vs_framework.png)
Ключевое отличие
- Библиотека: вы вызываете функции. В случае использования различных библиотек мы управляем ходом программы сами.
- Фреймворк: фреймворк вызывает ваш код. Мы реализуем часть логики приложения, которая потом управляется/вызывается через фреймворк. Это называется **Inversion of Control (IoC)**
```java
// Библиотека: ВЫ управляете
StringUtils.isEmpty("text");
// Фреймворк: ФРЕЙМВОРК управляет
@GetMapping("/users")
public String getUsers() {
return "users"; // Spring вызывает этот метод
}
```
- EJB (Enterprise JavaBeans) -> POJO (Plain Old Java Object) -> Java Spring
- Объяснение: 
	- **EJB** — тяжёлые серверные компоненты, жёстко завязанные на **контейнер Java EE**, который управляет жизненным циклом, транзакциями, безопасностью и т.д.  Код напрямую зависит от контейнера и плохо тестируется вне сервера.
    - **POJO** — подход (не стандарт!), при котором бизнес-логика пишется в виде **обычных Java-классов**: без обязательного наследования,  без серверных интерфейсов,  без контейнерных требований.
    - **Spring** — фреймворк, который **сделал POJO основой enterprise-разработки**, вынеся инфраструктуру (DI, транзакции, безопасность, AOP) **в контейнер вокруг кода**, а не внутрь него.
- **Java Spring** вобрал в себя POJO и реализацию EJB под капотом: «Пишем POJO, а Spring _незаметно_ делает EJB-подобные вещи»
![](spring_modules.png)
- На картинке показана модульная архитектура Spring Framework
	- **Spring Core** | В нём находятся базовые механизмы:
		- IoC / DI (Inversion of Control, Dependency Injection)
		- `BeanFactory`, `ApplicationContext`
		- управление жизненным циклом бинов
		- прокси-механизмы (основа AOP, транзакций, security)
		- **Без Spring Core ничего остального не работает.**
	- **Spring AOP**
	- **Spring Data** | Упрощённая работа с БД
		- Репозитории (`JpaRepository`, `CrudRepository`)
		- Генерация SQL/JPQL по названию методов
		- Использует:  Spring Core (бины, DI), Spring AOP (транзакции)
	- **Spring Security**
		- Аутентификация и авторизация
		- Фильтры
		- Роли, access rules, OAuth, JWT
		- Построен на: Spring Core, Spring AOP, Spring Context без них просто ничего не заработает
	- **Spring Boot — не часть ядра Spring**, а надстройка. Он:
		- автоматически конфигурирует все модули
		- поднимает embedded-сервер (Tomcat/Jetty) - то обёртка вокруг приложения, обеспечивающая HTTP-интерфейс при локальном запуске
		- убирает ручную конфигурацию
		- связывает всё воедино
		- **Spring-Application** – основной запуск приложения
		- **Lazy Initialization** – отложенная загрузка бинов
		- **Admin Features** – управление приложением
		- **Security** – аутентификация и авторизация
		- **Logging** – ведение логов
		- **Caching** – кэширование данных
		- **Kotlin Support** – поддержка языка Kotlin
		- **Validation** – проверка данных
		- **JSON** – работа с JSON
		- **Testing** – тестирование приложения
		- **Task Execution and Scheduling** – выполнение и планирование задач
### Проблема отсутствия DI
- Что такое Dependency Injection?
	- Паттерн для управления зависимостями
	- Зависимости предоставляются извне (например вместо инициализации объекта внутри класса, он передается извне как зависимость)
	- Устраняет жёсткие связи
- Проблемы (Без DI)
	- Невозможность тестирования 
		- Без внедрения зависимостей (Dependency Injection, DI) классы жестко создают свои зависимости внутри себя. Это делает почти невозможным **модульное тестирование**, так как нельзя подставить заглушки или моки для внешних сервисов — тесты будут зависеть от реальных реализаций.
	- Сложность замены реализации (особенно когда их становится много)
		- Когда зависимости создаются внутри класса, замена одной реализации на другую требует изменения самого класса. Особенно это усложняется, если таких зависимостей много — приходится искать все места, где они создаются, и менять их вручную, что повышает риск ошибок.
	- Нарушение SRP (Single Responsibility Principle)
		- Класс, который сам создаёт и управляет своими зависимостями, выполняет сразу две роли: **основную логику** и **управление зависимостями**. Это нарушает принцип единственной ответственности, делая класс менее поддерживаемым и более сложным для понимания.
	- Проблемы с жизненным циклом
		- Когда объект сам создаёт зависимости, сложно контролировать их **время жизни** (singleton, transient, scoped и т.д.). Это может привести к избыточному потреблению ресурсов, утечкам памяти или неожиданным состояниям, особенно в крупных приложениях.
	- Примеры DI
		- **Конструкторная инициализация** - Это классический способ, но его часто используют для того, чтобы гарантировать неизменяемость зависимости.
		- **Setter Injection** - DI через сеттеры используется, когда зависимость не обязательна на старте или должна меняться во время работы.
		- **Интерфейсы, конфигурацией объектов** - DI позволяет подставлять разные реализации интерфейсов без изменения кода, что важно в архитектуре больших проектов. Очень хороший пример - настройки consumer'а kafka для обработки сообщений через цепочку бинов 
	![](dependency_injection.png)
### Способы DI через spring
1. Field Injection (не рекомендуется)
	```java
		@Autowired
		private Repository repo;
	```
	- Почему не рекомендуется?
		1. Поле становится **жёстко привязанным к DI-контейнеру**, то есть нельзя где-то в каком-то месте создать объект через new() и передать туда зависимость отличную от той, что будет указана в DI-контейнере  -> проблемы с тестированием
		2. Его нельзя сделать `final`. Это означает, что класс сам не управляет своей зависимостью, и невозможно гарантировать, что объект будет корректно инициализирован до использования (какое-то время перед инициализацией он будет null)
			- почему нельзя?
			- JVM вызывает конструктор класса → объект создаётся, но поле `repo` ещё **null**. Spring использует **рефлексию** и записывает значение в приватное поле `repo` Отсюда 3-ий пункт
		3. Использование рефлексии -> bad practice, дорогостоящая операция при постоянном использовании
2. Setter Injection (не рекомендуется)
	```java
		@Autowired
		public void setRepo(Repository repo) {
			this.repo = repo;
		}
	```
	- Когда все таки надо использовать?
		1. цикличная зависимость  A inject B <-> B inject A. Setter Injection позволяет создать объекты сначала, а потом подставить зависимость, разрывая цикл.
		2. Для ленивой инициализации (Часто совмещается с 1ым пунктом)
	- почему не рекомендуется?
		1. Его нельзя сделать `final`  Конструктор будет проще: зависимости передаются сразу, объект сразу валидный.
			- Пункты ниже просто придирки, ничего критичного в остальных минусах нет
		2. При взгляде на конструктор класса **невозможно понять**, что нужно для работы.
		3. Внедрение через сеттер может быть пропущено, и объект окажется в неполностью инициализированном состоянии.
		4. Сложнее тестировать
3.  Constructor Injection (рекомендуется)
	```java
		private final Repository repo;
			public Service(Repository repo) {
				this.repo = repo;
		}
	```
	![](spring_IoC.png)
	- **Традиционный подход** 
		- Main → создаёт A → создаёт B → вызывает методы
	- **IOC-ПОДХОД**
		- IoC Container → создаёт B → создаёт A → Main запрашивает A
### Иерархия ApplicationContext
BeanFactory (базовый интерфейс)
↑
ApplicationContext (расширяет BeanFactory)
↑
ConfigurableApplicationContext (расширяет ApplicationContext)
├── AnnotationConfigApplicationContext (имплементация, как правило используют ее)
├── ClassPathXmlApplicationContext (имплементация)
- AnnotationConfigApplicationContext - имеет самый высокий уровень абстракции (читай самый простой и автоматизированный, то есть его не надо руками создавать, это сделает Spring на основе классов с аннотациями)
- Spring Boot автоматически создаёт контекст и подставляет Bean’ы из конфигурации, поэтому руками чаще всего **не создают AnnotationConfigApplicationContext**.
### Как создаётся контекст

#### a) Вручную (Java-конфигурация)

`AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);`

- Spring создаёт **`AnnotationConfigApplicationContext`** — реализация `ConfigurableApplicationContext`, которая:
    
    1. Сканирует `AppConfig` и ищет `@Bean` методы.
        
    2. Создаёт Bean’ы и управляет их жизненным циклом.
        
    3. Разрешает зависимости через DI (внедряет `MyRepository` в `MyService`).
        

> Все Bean’ы теперь **живут в этом контексте**.

### b) В Spring Boot

``` java 
@SpringBootApplication public class MyApp {
	public static void main(String[] args) {
		SpringApplication.run(MyApp.class, args);     
	}
}
```

- Spring Boot автоматически создаёт **`AnnotationConfigServletWebServerApplicationContext`** (расширение AnnotationConfigApplicationContext для веб-приложений).
- Он сам сканирует классы с `@Configuration`, `@Component`, `@Service` и создаёт Bean’ы
- Вам не нужно явно создавать контекст — Spring Boot делает это под капотом.
**ВАЖНО** при инжекте через конструктор Spring не смотрит на имя параметра в отличие от Field Injection через `@Autowired`

я ебал смотреть лекции и писать лонгриды, теперь буду просто писать пометки к существующим