### Работа с Fork-репозиториями

- Бывают большие и open-source проекты (например namespace с сетевыми доступами), которые быстро развиваются или меняются, что приводит к большому числу изменений кода и к появлению десятков и сотен веток от разных людей
- Если бы доступ к репозиториям с такими проектами был открытым, это бы привело к плохо-контролируемой разработке и каше в проекте - куча неактульных старых веток (если забыли удалить), пуш в чужие ветки и прочее...
- Для того чтобы это избежать пуш в репозиторий проекта доступен только владельцам, все остальные изменения 
	- создание fork'а репозитория
	- создание ветки **a** в fork (необязательный атрибут, но из практик разработки ему следуют)
	- внесение нужных изменений в ветке **a**
	- пуш изменений в fork репозитория
	- создание merge/pull-реквеста в родительский(оригинальный) репозиторий
- И так, что же все таки происходит, если расписать поподробнее
	- мы создали fork и склонировали его к себе локально
	- мы добавляем к себе в отслеживаемые репозитории оригинальный репозиторий, чаще всего называя его upstream. Как мы это делаем?
		- в idea: git -> manage remotes -> +  -> добавляем ссылку
		- idea выполняет команду `git remote add upstream <URL-родительского-репозитория>` - это заносит в кэш данные о всех ветках удаленного репозитория и их последних коммитов
		- когда мы выбираем ветку из upstream репозитория (или нашего, но которой нет локально) и переключаемся на нее idea делает следующее
			- `git checkout -b main upstream/main` - это создает локальную ветку
			- если бы мы сделали просто `git checkout upstream/main`, то локальная бы ветка не создалась, мы бы открыли состояние проекта на момент последнего коммита данной ветки и получили бы `Detached HEAD` - то есть данное состояние не будет привязано ни к какой ветке, в нем можно также делать коммиты, но если переключиться на какую-то ветку, то мы все потеряем, если не прилинкуем ветку или тэг к нашим коммитам
			- `HEAD` - указатель на ветку или конкретный коммит
			- все хэды храняться в папке гита, например
				- .git/refs/heads/main
				- .git/refs/heads/dev
			- при этом если посмотреть что вернет `cat .git/refs/heads/main` (читай - содержит в себе `HEAD` ссылающийся на ветку) то это будет хэш коммита (как правило последнего) `a1b2c3d4e5f67890abcd1234567890abcdef1234` на который эта ветка указывает
			- сам коммит при этом - это объект в папке `.git/objects/` и упрощенно он имеет в себе следующее содержимое
				- `commit D4E5F6` - сокращенный хэш того коммита, на который указывает ветка (`git cat-file -p D4E5F6` - Git ищет все объекты, начинающиеся на D4E5F6. Если совпадение уникальное — вернёт объект. Если совпадений несколько — выдаст ошибку, нужно указать больше символов)
				- `parent: A1B2C3` - сокращенный хэш родительского коммита 
				- `parent:` - может быть ссылка на второй, если предшевствовал merge
				- `tree:  F4E5D6` - snapshot файлов и каталогов на момент коммита. Tree хранит **структуру проекта**, но не сами файлы напрямую. Опять же git будет искать файлы начинающиеся на F4E5D6, он будет сжат, но после распаковки содержимое файла будет примерно такое
				  tree F1E2D3
					├── README.md → blob C1C2C3 - зазипованный файл, хранящий полное содержимое на момент коммита
					└── src/      → tree B1B2B3 - ссылка на такое же дерево с другими блобами и тд.
				    └── main.py → blob D1D2D3 - другой блоб, другой файл
				- `author: Bob`
				- `message: Added feature`
				- однако в какой-то момент, чтобы проект много не весил git начинает хранить `pack` - `.git/objects/pack/` - дельты файлов 
		- когда мы делаем checkout в idea на ветку, которая уже существует, git просто восстанавливает структуру проекта по последнему(важно что **локальному**) коммиту, на который эта ветка указывает
		- когда наш fork долго простаивал и в upstream появилось много новых коммитов при создании ветки в idea надр обязательно делать fetch, чтобы idea подтянула актуальное состояние ветки репозитория, с которой мы делаем checkout

