### Работа с Fork-репозиториями

- Бывают большие и open-source проекты (например namespace с сетевыми доступами), которые быстро развиваются или меняются, что приводит к большому числу изменений кода и к появлению десятков и сотен веток от разных людей
- Если бы доступ к репозиториям с такими проектами был открытым, это бы привело к плохо-контролируемой разработке и каше в проекте - куча неактульных старых веток (если забыли удалить), пуш в чужие ветки и прочее...
- Для того чтобы это избежать пуш в репозиторий проекта доступен только владельцам, все остальные изменения 
	- создание fork'а репозитория
	- создание ветки **a** в fork (необязательный атрибут, но из практик разработки ему следуют)
	- внесение нужных изменений в ветке **a**
	- пуш изменений в fork репозитория
	- создание merge/pull-реквеста в родительский(оригинальный) репозиторий
- И так, что же все таки происходит, если расписать поподробнее
	- мы создали fork и склонировали его к себе локально
	- мы добавляем к себе в отслеживаемые репозитории оригинальный репозиторий, чаще всего называя его upstream. Как мы это делаем?
		- в idea: git -> manage remotes -> +  -> добавляем ссылку
		- idea выполняет команду `git remote add upstream <URL-родительского-репозитория>` - это заносит в кэш данные о всех ветках удаленного репозитория и их последних коммитов
		- когда мы выбираем ветку из upstream репозитория (или нашего, но которой нет локально) и переключаемся на нее idea делает следующее
			- `git checkout -b main upstream/main` - это создает локальную ветку
			- если бы мы сделали просто `git checkout upstream/main`, то локальная бы ветка не создалась, мы бы открыли состояние проекта на момент последнего коммита данной ветки и получили бы `Detached HEAD` - то есть данное состояние не будет привязано ни к какой ветке, в нем можно также делать коммиты, но если переключиться на какую-то ветку, то мы все потеряем, если не прилинкуем ветку или тэг к нашим коммитам
			- `HEAD` - указатель на ветку или конкретный коммит
			- все хэды храняться в папке гита, например
				- .git/refs/heads/main
				- .git/refs/heads/dev
			- при этом если посмотреть что вернет `cat .git/refs/heads/main` (читай - содержит в себе `HEAD` ссылающийся на ветку) то это будет хэш коммита (как правило последнего) `a1b2c3d4e5f67890abcd1234567890abcdef1234` на который эта ветка указывает
			- сам коммит при этом - это объект в папке `.git/objects/` и упрощенно он имеет в себе следующее содержимое
				- `commit D4E5F6` - сокращенный хэш того коммита, на который указывает ветка (`git cat-file -p D4E5F6` - Git ищет все объекты, начинающиеся на D4E5F6. Если совпадение уникальное — вернёт объект. Если совпадений несколько — выдаст ошибку, нужно указать больше символов)
				- `parent: A1B2C3` - сокращенный хэш родительского коммита 
				- `parent:` - может быть ссылка на второй, если предшевствовал merge
				- `tree:  F4E5D6` - snapshot файлов и каталогов на момент коммита. Tree хранит **структуру проекта**, но не сами файлы напрямую. Опять же git будет искать файлы начинающиеся на F4E5D6, он будет сжат, но после распаковки содержимое файла будет примерно такое
				  tree F1E2D3
					├── README.md → blob C1C2C3 - зазипованный файл, хранящий полное содержимое на момент коммита
					└── src/      → tree B1B2B3 - ссылка на такое же дерево с другими блобами и тд.
				    └── main.py → blob D1D2D3 - другой блоб, другой файл
				- `author: Bob`
				- `message: Added feature`
				- однако в какой-то момент, чтобы проект много не весил git начинает хранить `pack` - `.git/objects/pack/` - дельты файлов 
		- когда мы делаем checkout в idea на ветку, которая уже существует, git просто восстанавливает структуру проекта по последнему(важно что **локальному**) коммиту, на который эта ветка указывает
		- когда наш fork долго простаивал и в upstream появилось много новых коммитов при создании ветки из upstream-репозитория в idea обязательно делать fetch, чтобы idea подтянула актуальное состояние ветки репозитория, с которой мы делаем checkout и когда мы делаем чекаут руками, выполняя команды git вручную, также надо надо обязательно 
			- либо `git fetch upstream` и затем `git checkout -b feature upstream/main`
			- либо `git switch -c feature upstream/main`
		- в случае с rebase или merge ситуация аналогична
### 4 всадника апокалипсиса idea
-  Пусть у нас ветка, коммиты которой уже вмерджили в мастер, но мы хотим продолжить в ней работу и нам надо довести ее до актуального состояния используя команды idea предварительно выполнив fetch
1. `Merge 'upstream/master' into 'aaa-merge'` 
	1. если в `aaa-merge` не было коммитов или все коммиты, которые были уже давно *вмержены* в мастер
		- git поймет, что все коммиты, которые были в нашей ветке уже есть в мастере и git просто сместит указатель ветки на последний коммит в master
	2. если в `aaa-merge` все коммиты, которые были уже давно *rebase-нуты* в мастер, а в мастере не будет новых отличных от наших коммитов
		- git  не поймет, что все коммиты, которые были в нашей ветке уже есть в мастере и git номинально создаст merge коммит который зафиксирует слияние двух веток, но номинально изменений в коммите не будет (не покажуться)
	3. если в `aaa-merge` все коммиты, которые были уже давно *rebase-нуты* в мастер, а в мастере есть новые отличных от наших коммиты
		- git в любом случае создаст merge коммит который зафиксирует слияние двух веток и покажет изменения полученные от мастера, включая rebase-нутые коммиты
	4. если в `aaa-merge` все коммиты, которые были уже давно *вмержены* в мастер, а в мастере есть новые отличных от наших коммиты
		- git в любом случае создаст merge коммит который зафиксирует слияние двух веток и покажет изменения полученные от мастера, не включая merge-нутые коммиты
2. `Rebase 'aaa-rebase' onto 'upstream/master"`
	1. если в `aaa-rebase` не было коммитов или все коммиты, которые были уже давно *вмержены* в мастер, а мастер как уйти так и не уйти вперед
		- git поймет, что все коммиты, которые были в нашей ветке уже есть в мастере и git просто сместит указатель ветки на последний коммит в master
	2. если в `aaa-rebase` все коммиты, которые были уже давно *rebase-нуты* в мастер, а мастер либо ушел либо не ушел вперед
		- git  не поймет, что все коммиты, которые были в нашей ветке уже есть в мастере и git повторно перенесет наши коммиты в ветку. Код может содержать **дубли F1/F1'**, если Git не сможет автоматически объединить идентичные изменения
3. `Pull into 'aaa-pull-rebase' Using Rebase` - fetch + rebase
4. `Pull into 'aaa-pull-merge' Using Merge` - fetch + merge


